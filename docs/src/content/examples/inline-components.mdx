# Creating inline, semantic styles

Often we don't want to define each part of the style as a separate styled component outside of our React component. 

For example:
- when some styled part is simple, 
- or when we rapidly iterate.

To do that, we can use `UI` object imported from `stylings`.

## Creating simple inline components

The simplest way is to use `<UI.div>`, `<UI.span>` etc.

```tsx
import { UI, $flex } from "stylings";

<UI.div styles={[$flex.vertical.gap(2)]}>Content</UI.div>;
```

Those components are almost identical to regular divs, etc, but they also accept `styles` prop with a list of composable styles to use.

## Named inline components (recommended)

In the example above:

```tsx
<UI.div styles={$flex.vertical.gap(2)}>Content</UI.div>;
```


We describe how something looks, but not what it is and what is the meaning of it.

This can make it harder to read, understand and reason about the code. Also, when debugging such components in the browser, it might be hard to find which part of the result code corresponds to which component.

Using `UI`, we can also dynamically create named inline components.

You can use `UI.AnyNameYouWant` and `stylings` will dynamically create a component with that name.

```tsx
import { UI, $flex, font, box } from "stylings";

// From previous example
import { typo } from "./typo";

function BlogPost() {
  return (
    <UI.Holder styles={$flex.vertical.gap(2)}>
      <UI.Title styles={typo.$header}>Blog post</UI.Title>
      <UI.Content styles={$flex.vertical.gap(2)}>
        <UI.Intro styles={typo.$copy.secondary}>
          Intro here
        </UI.Intro>
        <UI.Body styles={$flex.vertical.gap(2)}>
          Content
        </UI.Body>
      </UI.Content>
    </UI.Holder>
  );
}
```

In this example, each part of the blog post component is semantically meaningful.

When debugging in the browser devtools, component like:

```tsx
function BlogPost() {
  return (
    <UI.Holder styles={$flex.vertical.gap(2)}>
      <UI.Title styles={typo.$header}>Blog post</UI.Title>
      { /* ... */ }
    </UI.Holder>
  );
}
```

Will resolve into HTML like:

```html
<div data-ui="BlogPost.Holder" class="sc-abcdefg">
  <div data-ui="BlogPost.Title" class="sc-abcdefg">Blog post</div>
</div>
```

> [!NOTE]
>
> `data-ui` attribute is only added during development. In production, it will not be present by default.
>
> `data-ui` consists of two parts: `ParentComponentName.InlineComponentName`. The first part is experimental as it is based on React internal API in order to find the parent component. Even as experimental, it is always guarded and will never crash the app.
>
> `UI.AnyName` is cached. When using the same name multiple times, `stylings` will return the same component.

## Creating non-`div` named inline components

By default, `UI.AnyNameYouWant` will resolve into `<div>` element.

If you want to use a different element, you convention: 
- `UI.AnyNameYouWant_h1`
- `UI.AnyNameYouWant_span`
- `UI.AnyNameYouWant_p`
- etc.

We can rewrite the previous example to use `h1` and `p` elements:

```tsx
import { UI, $flex, font, box } from "stylings";

// From previous example
import { typo } from "./typo";

function BlogPost() {
  return (
    <UI.Holder styles={$flex.vertical.gap(2)}>
      <UI.Title_h1 styles={typo.$header}>Blog post</UI.Title_h1>
      <UI.Content styles={$flex.vertical.gap(2)}>
        <UI.Intro_p styles={typo.$copy.secondary}>
          Intro here
        </UI.Intro_p>
        <UI.Body_p styles={$flex.vertical.gap(2)}>
          Content
        </UI.Body_p>
      </UI.Content>
    </UI.Holder>
  );
}
```

> [!NOTE]
>
> All components created with `Name_tag` will be TypeScript type safe. Typescript will automatically infer the correct type for the component basing on the tag in the name.
>
> Eg. ref passed to `UI.Title_h1` will need to be of type `RefObject<HTMLHeadingElement>`.
>

On top of `UI.Name_tag` convention, you can also pass `as` prop to the component.

```tsx
// Defined as h3, displayed as a
<UI.Title_h3 as="a">Blog post</UI.Title>
```

In this case, however, Typescript will still assume that the component is based on `h3` element.